#pragma once

#include <JuceHeader.h>
#include "plugin_process_callback.h"        // <<< опечатка была в исходнике
#include "cpu_load.h"                       // индикатор CPU
#include "custom_audio_playhead.h"
#include <vector>

/* ────────────────────────────────────────────────────────────
   Структура-описание одного параметра плагина
   ──────────────────────────────────────────────────────────── */
struct ParameterInfo
{
    int           index;
    juce::String  name;
};

//==========================================================================
// Компонент-редактор параметров плагина (оставлен без изменений логики)
//==========================================================================
class PluginParameterEditorComponent : public juce::Component,
                                       public juce::Slider::Listener
{
public:
    explicit PluginParameterEditorComponent (juce::AudioPluginInstance* plugin)
        : pluginInstance (plugin)
    {
        if (pluginInstance == nullptr) return;

        auto& params = pluginInstance->getParameters();
        for (int i = 0; i < params.size(); ++i)
        {
            auto* s = new juce::Slider();
            s->setRange (0.0, 1.0, 0.001);
            s->setValue (params[i]->getValue(), juce::dontSendNotification);
            s->setTextBoxStyle (juce::Slider::TextBoxRight, false, 80, 20);
            s->addListener (this);
            addAndMakeVisible (s);
            parameterSliders.add (s);

            auto* l = new juce::Label();
            l->setText (params[i]->getName (100), juce::dontSendNotification);
            addAndMakeVisible (l);
            parameterLabels.add (l);
        }
        setSize (400, params.size() * 40 + 20);
    }

    ~PluginParameterEditorComponent() override = default;

    void sliderValueChanged (juce::Slider* s) override
    {
        auto& params = pluginInstance->getParameters();
        for (int i = 0; i < parameterSliders.size(); ++i)
            if (parameterSliders[i] == s)
            {
                pluginInstance->setParameterNotifyingHost (
                    i, (float) s->getValue());
                break;
            }
    }

    void paint (juce::Graphics& g) override
    {
        g.fillAll (getLookAndFeel()
                   .findColour (juce::ResizableWindow::backgroundColourId));
    }

    void resized() override
    {
        int y = 10;
        for (int i = 0; i < parameterSliders.size(); ++i)
        {
            auto area = juce::Rectangle<int> (10, y, getWidth() - 20, 30);
            parameterLabels [i]->setBounds (area.removeFromLeft (120));
            parameterSliders[i]->setBounds (area);
            y += 40;
        }
    }

private:
    juce::AudioPluginInstance*            pluginInstance { nullptr };
    juce::OwnedArray<juce::Slider>        parameterSliders;
    juce::OwnedArray<juce::Label>         parameterLabels;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (PluginParameterEditorComponent)
};

//==============================================================================
// VSTHostComponent: пока структура 1:1 с оригиналом; изменения помечены
//==============================================================================
class VSTHostComponent : public juce::Component,
                         public juce::ListBoxModel,            // <<< удалить
                         public juce::Button::Listener,         // <<< удалить
                         public juce::AudioProcessorParameter::Listener
{
public:
    // Конструктор по умолчанию
    VSTHostComponent();

    // Конструктор с заданным AudioDeviceManager
    VSTHostComponent (juce::AudioDeviceManager& adm);

    /* …декларации всех публичных методов остаются как в оригинале… */
///////////////////////////////////////////////////////////////////////////////////////////////////
    // Метод для обновления загрузки CPU плагина  (оставляем)
    void updatePluginCpuLoad (double load)
    {
        lastPluginCpuLoad = load;
        globalCpuLoad.store (load);
    }
    double getLastPluginCpuLoad() const { return lastPluginCpuLoad; }

    // Вернуть ссылку на AudioDeviceManager
    juce::AudioDeviceManager& getAudioDeviceManagerRef()    { return audioDeviceManager; }

    //------------------------------------------------------------------------
    // BPM-интерфейс (остаётся)
    //------------------------------------------------------------------------
    void setBpmDisplayLabel (juce::Label* label)            { bpmDisplay = label; }

    void updateBPM (double newBPM)
    {
        if (customAudioPlayHead) customAudioPlayHead->setBpm (newBPM);

        if (bpmDisplay != nullptr)
        {
            bpmDisplay->setText (juce::String (newBPM, 2) + " BPM",
                                 juce::dontSendNotification);
            bpmDisplay->repaint ();
        }
    }

    // Метод для сброса BPM
    void resetBPM()
    {
        const double defaultBPM = 120.0;
        updateBPM (defaultBPM);
    }

    //------------------------------------------------------------------------
    //  ~VSTHostComponent
    //------------------------------------------------------------------------
    ~VSTHostComponent() override
    {
        unloadPlugin ();
        resetBPM ();
    }

    //------------------------------------------------------------------------
    //  setPluginParameter
    //------------------------------------------------------------------------
#if 0   // <<< удалить direct-call версию
    void setPluginParameter (int ccNumber, int ccValue)
    {
        if (pluginInstance != nullptr)
        {
            auto& params = pluginInstance->getParameters();
            if (ccNumber >= 0 && ccNumber < params.size())
            {
                float normalizedValue = ccValue / 127.0f;
                pluginInstance->setParameterNotifyingHost (ccNumber, normalizedValue);
            }
        }
    }
#endif
    // <<< добавлено: RT-safe версия (кладёт команду в lock-free очередь)
    void setPluginParameter (int ccNumber, int ccValue)
    {
        if (pluginPtr == nullptr) return;                 // pluginPtr появится позже
        float norm = juce::jlimit (0.0f, 1.0f, ccValue / 127.0f);

        int start;
        if (cmdFifo.write (1, start))
        {
            cmdBuf[start] = { ccNumber, norm };
            cmdFifo.finishedWrite (1);
        }
    }

    //------------------------------------------------------------------------
    //  ListBoxModel / Buttons  (будут удалены целиком)
    //------------------------------------------------------------------------
#if 0   // <<< удалить весь блок ListBox + buttons
    int  getNumRows() override                            { … }
    void paintListBoxItem (…) override                    { … }
    void listBoxItemClicked (…) override                  { … }

    void buttonClicked (juce::Button* b) override         { … }
#endif

    //------------------------------------------------------------------------
    // resized()
    //------------------------------------------------------------------------
#if 0   // <<< старая гибридная верстка – удалить
    void resized() override
    {
        … (код с closeButton / parametersButton / pluginListBox) …
    }
#endif
    // <<< новая упрощённая версия (только редактор плагина)
    void resized() override
    {
        if (pluginEditor != nullptr)
            pluginEditor->setBounds (getLocalBounds().reduced (4));
    }

    //------------------------------------------------------------------------
    // setAudioSettings (оставляем без изменений)
    //------------------------------------------------------------------------
    void setAudioSettings (double sampleRate, int blockSize)
    {
        currentSampleRate = sampleRate;
        currentBlockSize  = blockSize;
    }

    //------------------------------------------------------------------------
    // loadPlugin() — оставим сигнатуру, реализацию поменяем в части 3
    //------------------------------------------------------------------------
    void loadPlugin (const juce::File& pluginFile,
                     double sampleRate,
                     int    blockSize);

    // Метод-getter
    juce::AudioPluginInstance* getPluginInstance() { return pluginPtr; }  // <<< pluginPtr

    //------------------------------------------------------------------------
    // Переключение пресетов  (логика сохранилась)
    //------------------------------------------------------------------------
    void switchPresetUp  ();
    void switchPresetDown();

    //------------------------------------------------------------------------
    // … дальнейшие методы остаются как в оригинале …
///////////////////////////////////////////////////////////////////////////////////////////////////////
private:
    // Общий метод инициализации компонента
    void initialiseComponent()
    {
        /* …функция остаётся, но весь блок создания ListBox & кнопок
           будет отключён; actual GUI-элементы можно оставить в коде,
           но setVisible() / addAndMakeVisible() вызовы будут закомментированы
           чтобы не создавать и не показывать лишние компоненты… */

#if 0   // <<< удалить визуальные контролы
        addAndMakeVisible (pluginListBox);
        pluginListBox.setModel (this);

        loadButton.setButtonText ("Load Plugin");
        loadButton.addListener  (this);
        addAndMakeVisible       (loadButton);

        closeButton.setButtonText ("Close Plugin");
        closeButton.addListener  (this);
        addAndMakeVisible        (closeButton);

        parametersButton.setButtonText ("Edit Parameters");
        parametersButton.addListener  (this);
        addAndMakeVisible        (parametersButton);
#endif
        // <<< добавлено: больше ничего не показываем, только автозагрузка ↓

        // ── автозагрузка сохранённого плагина ──
        juce::AudioIODevice* dev = audioDeviceManager.getCurrentAudioDevice();
        double sr = dev ? dev->getCurrentSampleRate()        : currentSampleRate;
        int    bs = dev ? dev->getCurrentBufferSizeSamples() : currentBlockSize;
        juce::File last = loadLastSelectedPluginFile();
        if (last.existsAsFile())
            loadPlugin (last, sr, bs);
    }

    /* ========= helpers save/load path (оставляем) ========= */
    void saveSelectedPluginFile (const juce::File& file);
    juce::File loadLastSelectedPluginFile();
    void clearSavedPluginFile();

    /* ========= UNLOAD  (новая упрощённая версия) ========= */
    void unloadPlugin()
    {
        audioDeviceManager.removeAudioCallback (hostCallback.get());
        hostCallback.reset();

        if (pluginEditor)
        {
            removeChildComponent (pluginEditor);
            delete pluginEditor;
            pluginEditor = nullptr;
        }

        graph.reset();                    // уничтожит pluginPtr
        pluginNode = nullptr;
        pluginPtr  = nullptr;

        updatePluginCpuLoad (0.0);
        resetBPM();
        resized();
    }

    /* ========= AudioProcessorParameter::Listener ========= */
    void parameterValueChanged (int idx, float v) override
    {
        if (paramChangeCb)
            juce::MessageManager::callAsync ([=] {
                if (paramChangeCb) paramChangeCb (idx, v);
            });
    }
    void parameterGestureChanged (int, bool) override {}

    // ────────────────────────────────────────────────────────
    //                 П О Л Я   К Л А С С А
    // ────────────────────────────────────────────────────────

    /*  1.  Было  */
    juce::PluginProcessCallback*  pluginProcessCallback = nullptr; // <<< удалить
    juce::ListBox         pluginListBox;                          // <<< удалить
    juce::TextButton      loadButton, closeButton, parametersButton; // <<< удалить

    /*  2.  Новое  */
    struct Cmd { int param; float value; };         // <<< добавлено
    juce::AbstractFifo  cmdFifo { 256 };            // <<< добавлено
    std::array<Cmd,256> cmdBuf;                     // <<< добавлено

    std::unique_ptr<juce::AudioProcessorGraph> graph;           // <<< добавлено
    juce::AudioProcessorGraph::Node::Ptr       pluginNode;      // <<< добавлено
    juce::AudioPluginInstance*                 pluginPtr = nullptr; // raw, владеет graph

    class HostAudioCallback;                                 // <<< добавлено
    std::unique_ptr<HostAudioCallback>        hostCallback;  // <<< добавлено

    /*  3.  Остальное (оставляем без изменений)  */
    juce::Array<juce::File>          pluginFiles;
    int                              selectedIndex = -1;

    std::unique_ptr<juce::AudioPluginInstance> pluginInstance; // <<< устарело, но оставляем, если используется где-то ещё

    juce::Component*                 pluginEditor = nullptr;
    juce::AudioDeviceManager&        audioDeviceManager;
    double                           currentSampleRate;
    int                              currentBlockSize;

    std::unique_ptr<CustomAudioPlayHead> customAudioPlayHead;
    juce::Label*                     bpmDisplay = nullptr;

    std::atomic<double>              globalCpuLoad { 0.0 };
    ParamChangeFn                    paramChangeCb;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (VSTHostComponent)
};

/*======================================================================
  getCurrentPluginParameters()  –  код оставляем прежним,
  только используем pluginPtr вместо pluginInstance
======================================================================*/
inline std::vector<ParameterInfo>
VSTHostComponent::getCurrentPluginParameters() const
{
    std::vector<ParameterInfo> list;
    if (pluginPtr)
    {
        auto& params = pluginPtr->getParameters();
        list.reserve (params.size());
        for (int i = 0; i < params.size(); ++i)
            list.push_back ({ i, params[i]->getName (100) });
    }
    return list;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
//==============================================================================
//   inline-реализация, которую вы уже имели за классом
//   (строка была в исходном файле – оставляем без изменений,
//   но используем pluginPtr вместо pluginInstance)
//==============================================================================

inline std::vector<ParameterInfo>
VSTHostComponent::getCurrentPluginParameters() const
{
    std::vector<ParameterInfo> list;

    if (pluginPtr != nullptr)                          // было pluginInstance
    {
        auto& params = pluginPtr->getParameters();
        list.reserve (params.size());

        for (int i = 0; i < params.size(); ++i)
            list.push_back ({ i, params[i]->getName (100) });
    }
    return list;
}

//==============================================================================
//  (больше кода после этой функции в оригинале не было)
//==============================================================================

#endif   //  VST_HOST_H  ─── если у вас есть include-guard,
         //                 оставьте его именно здесь
