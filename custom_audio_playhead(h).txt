#pragma once
#include <JuceHeader.h>

class CustomAudioPlayHead : public juce::AudioPlayHead
{
public:
    CustomAudioPlayHead() : currentBpm(120.0), active(false) {}
    ~CustomAudioPlayHead() override {}

    // Метод, позволяющий включать/выключать транспорт
    void setActive(bool newState) { active = newState; }

    // Метод для задания BPM
    void setBpm(double newBpm) { currentBpm = newBpm; }

    // Полная реализация getPosition()
    juce::Optional<juce::AudioPlayHead::PositionInfo> getPosition() const override
    {
        // Если метод вызывается не из главного (UI) потока, возвращаем пустой Optional
        if (!juce::MessageManager::getInstance()->isThisTheMessageThread())
            return {};

        // Если транспорт не активен, также возвращаем пустой Optional
        if (!active)
            return {};

        juce::AudioPlayHead::PositionInfo info;

        // Устанавливаем BPM
        info.setBpm(currentBpm);

        // Получаем текущее время в секундах
        const double now = juce::Time::getMillisecondCounterHiRes() / 1000.0;
        info.setTimeInSeconds(now);

        // Определяем PPQ-позицию на основе времени (при необходимости заменить на корректную логику)
        const double ppq = (now > 0.0) ? now : 1.0;
        info.setPpqPosition(ppq);
        info.setPpqPositionOfLastBarStart(ppq - std::fmod(ppq, 4.0)); // для 4/4 тактовой сигнатуры

        // Задаем тактовую сигнатуру (4/4)
        juce::AudioPlayHead::TimeSignature ts{ 4, 4 };
        info.setTimeSignature(ts);

        // Указываем тип кадров – здесь используем fpsUnknown, если без дополнительной информации
        info.setFrameRate(juce::AudioPlayHead::FrameRateType::fpsUnknown);

        // Сообщаем, что воспроизведение активно, а запись выключена
        info.setIsPlaying(true);
        info.setIsRecording(false);

        return info;
    }

private:
    double currentBpm;
    bool active;
};