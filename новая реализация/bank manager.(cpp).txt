#include "bank manager.h"     // здесь только прототипы, без реализаций
#include "vst_host.h"         // полный VSTHostComponent
#include "SetCCDialog.h"   // CCMapping, CCMapArray и SetCCDialog


//==============================================================================
// Конструктор вложенной структуры Bank
//==============================================================================
BankManager::Bank::Bank()
    : bankName("Untitled"),
    presetNames({ "PRESET 1", "PRESET 2", "PRESET 3",
                      "PRESET 4", "PRESET 5", "PRESET 6" }),
    ccPresetStates(6, std::vector<bool>(10, false)),
    presetVolumes(6, 1.0f),
    pluginPreset(0)
{
    // ccMappings default-конструируется через CCMapping()
}

//==============================================================================
// ctor / dtor
//==============================================================================
BankManager::BankManager(VSTHostComponent* hostToUse)
    : vstHost(hostToUse)
{
    // 1) Модель: 15 банков по 6 пресетов
    banks.resize(15);
    for (int i = 0; i < (int)banks.size(); ++i)
    {
        banks[i].bankName = "BANK " + juce::String(i + 1);
        banks[i].presetNames.clear();
        for (int j = 0; j < 6; ++j)
            banks[i].presetNames.add("PRESET " + juce::String(j + 1));
    }
    currentBankIndex = 0;

    // 2) Контейнер строк внутри viewport
    rowContainer = std::make_unique<juce::Component>();
    addAndMakeVisible(rowContainer.get());

    // 3) Создаём BankRow для каждого банка
    for (int i = 0; i < (int)banks.size(); ++i)
    {
        auto row = std::make_unique<BankRow>(i,
            banks[i].bankName,
            banks[i].presetNames);

        row->onRowChanged = [this](int bankIndex)
            {
                auto& b = banks[bankIndex];
                b.bankName = bankRows[bankIndex]->getBankName();
                for (int j = 0; j < 6; ++j)
                {
                    b.presetNames.set(j, bankRows[bankIndex]->getPresetName(j));
                    b.presetVolumes[j] = bankRows[bankIndex]->getPresetVolume(j);
                    b.ccPresetStates[j] = bankRows[bankIndex]->getCCStates(j);
                }
                b.pluginPreset = bankRows[bankIndex]->getPluginPresetNumber();

                if (onBankManagerChanged) onBankManagerChanged();
                restartAutoSaveTimer();
            };

        row->onMappingChanged = [this](int bankIndex, int ccIndex, int newValue)
            {
                auto& m = banks[bankIndex].ccMappings[ccIndex];
                m.ccValue = static_cast<uint8_t> (juce::jlimit(0, 127, newValue));
                m.enabled = true;

                if (onBankManagerChanged) onBankManagerChanged();
                restartAutoSaveTimer();
            };

        rowContainer->addAndMakeVisible(row.get());
        bankRows.add(std::move(row));
    }

    // 4) Кнопки Set CC1…Set CC10
    for (int slot = 0; slot < (int)banks.front().ccMappings.size(); ++slot)
    {
        auto* btn = new juce::TextButton("Set CC " + juce::String(slot + 1));
        btn->setComponentID(juce::String(slot));
        btn->addListener(this);
        addAndMakeVisible(btn);
        setCCButtons.add(btn);
    }

    // 5) Кнопка сброса дефолтов
    resetDefaultsButton.setButtonText("Reset Defaults");
    resetDefaultsButton.addListener(this);
    addAndMakeVisible(&resetDefaultsButton);

    // 6) Viewport
    addAndMakeVisible(&viewport);
    viewport.setViewedComponent(rowContainer.get(), false);

    // 7) Загрузка настроек + начальная подсветка + автосохранение
    loadSettingsFromFile(juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory)
        .getChildFile("BankManagerSettings.ini"));
    updateRowHighlighting();
    startTimer(2000);
}

BankManager::~BankManager()
{
    stopTimer();
}

//==============================================================================
// getBanks / getActiveBankIndex / setActiveBankIndex
//==============================================================================
// Доступ к данным
const std::vector<BankManager::Bank>& BankManager::getBanks() const noexcept { return banks; }

std::vector<BankManager::Bank>& BankManager::getBanks() noexcept { return banks; }

int  BankManager::getActiveBankIndex() const noexcept { return currentBankIndex; }

//==============================================================================
// Доступ к отдельному банку по индексу
//==============================================================================
const BankManager::Bank& BankManager::getBank(int index) const noexcept
{
    jassert(index >= 0 && index < (int)banks.size());
    return banks[index];     // вместо getReference()
}

BankManager::Bank& BankManager::getBank(int index) noexcept
{
    jassert(index >= 0 && index < (int)banks.size());
    return banks[index];     // вместо getReference()
}


void BankManager::setActiveBankIndex(int newIndex)
{
    if (newIndex >= 0 && newIndex < (int)banks.size() && newIndex != currentBankIndex)
    {
        currentBankIndex = newIndex;
        if (onBankManagerChanged) onBankManagerChanged();
        updateRowHighlighting();
    }
}

void BankManager::setPluginPresetSupported(bool supported)
{
    for (auto* r : bankRows)
        r->setPluginPresetEnabled(supported);
}

//==============================================================================
// updateRowHighlighting — подсвечивает текущий банк
//==============================================================================

void BankManager::updateRowHighlighting()
{
    for (int i = 0; i < bankRows.size(); ++i)
        bankRows[i]->setVisible(i == currentBankIndex);

    // чтобы сразу перепозиционировались и кнопки/viewport
    resized();
}

//==============================================================================
// paint / resized
//==============================================================================
void BankManager::paint(juce::Graphics& g)
{
    g.fillAll(juce::Colours::transparentBlack);
}

void BankManager::resized()
{
    auto area = getLocalBounds();
    auto topBar = area.removeFromTop(30);

    int num = (int)setCCButtons.size();
    int btnCount = juce::jmax(1, num);
    int btnWidth = topBar.getWidth() / btnCount;

    for (auto* b : setCCButtons)
        b->setBounds(topBar.removeFromLeft(btnWidth).reduced(2));

    auto bot = area.removeFromBottom(40);
    resetDefaultsButton.setBounds(bot.reduced(10));

    viewport.setBounds(area);

    constexpr int rowH = 100, gap = 8;
    rowContainer->setSize(viewport.getWidth(), rowH + gap);
    for (int i = 0; i < bankRows.size(); ++i)
    {
        if (i == currentBankIndex)
            bankRows[i]->setBounds(0, 0, viewport.getWidth(), rowH);

        bankRows[i]->setVisible(i == currentBankIndex);
    }
}

//==============================================================================
// buttonClicked
//==============================================================================
void BankManager::buttonClicked(juce::Button* b)
{
    if (b == &resetDefaultsButton)
    {
        resetAllDefaults();
        return;
    }

    for (int slot = 0; slot < setCCButtons.size(); ++slot)
    {
        if (setCCButtons[slot] == b)
        {
            auto initMap = banks[currentBankIndex].ccMappings[slot];

            // Запускаем модальный диалог
            new SetCCDialog(vstHost,
                initMap,
                "Set CC " + juce::String(slot + 1),
                [this, slot](CCMapping newMap, bool ok)
                {
                    if (!ok)
                        return;
                    banks[currentBankIndex].ccMappings[slot] = newMap;
                    if (onBankManagerChanged)
                        onBankManagerChanged();
                    restartAutoSaveTimer();
                });

            return;
        }
    }
}

//==============================================================================
// Timer для автосохранения
//==============================================================================
void BankManager::timerCallback()
{
    saveSettingsToFile(juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory)
        .getChildFile("BankManagerSettings.ini"));
    stopTimer();
}

void BankManager::restartAutoSaveTimer()
{
    stopTimer();
    startTimer(2000);
}

//==============================================================================
// Сохранение / загрузка
//==============================================================================
void BankManager::saveSettingsToFile(const juce::File& configFile)
{
    juce::PropertiesFile::Options opts;
    opts.applicationName = "MyBankManagerApp";
    juce::PropertiesFile props(configFile, opts);

    for (int i = 0; i < (int)banks.size(); ++i)
    {
        auto& b = banks[i];
        props.setValue("bankName_" + juce::String(i), b.bankName);

        for (int j = 0; j < 6; ++j)
        {
            props.setValue("bank_" + juce::String(i)
                + "_preset_" + juce::String(j),
                b.presetNames[j]);

            // ccPresetStates
            juce::String stateStr;
            for (int k = 0; k < (int)b.ccPresetStates[j].size(); ++k)
            {
                stateStr += b.ccPresetStates[j][k] ? '1' : '0';
                if (k < (int)b.ccPresetStates[j].size() - 1)
                    stateStr += ',';
            }
            props.setValue("bank_" + juce::String(i)
                + "_ccStates_" + juce::String(j),
                stateStr);

            // presetVolumes
            props.setValue("bank_" + juce::String(i)
                + "_volume_" + juce::String(j),
                (double)b.presetVolumes[j]);
        }

        // полный CC-mapping
        juce::String idxStr, enStr, valStr;
        for (int k = 0; k < (int)b.ccMappings.size(); ++k)
        {
            auto& m = b.ccMappings[k];
            idxStr += juce::String(m.paramIndex);
            enStr += m.enabled ? '1' : '0';
            valStr += juce::String((int)m.ccValue);

            if (k < (int)b.ccMappings.size() - 1)
            {
                idxStr += ','; enStr += ','; valStr += ',';
            }
        }
        props.setValue("bank_" + juce::String(i) + "_ccParamIndices", idxStr);
        props.setValue("bank_" + juce::String(i) + "_ccEnabled", enStr);
        props.setValue("bank_" + juce::String(i) + "_ccValues", valStr);

        props.setValue("bank_" + juce::String(i) + "_pluginPreset",
            b.pluginPreset);
    }

    props.saveIfNeeded();
}

void BankManager::loadSettingsFromFile(const juce::File& configFile)
{
    if (!configFile.existsAsFile())
        return;

    juce::PropertiesFile::Options opts;
    opts.applicationName = "MyBankManagerApp";
    juce::PropertiesFile props(configFile, opts);

    for (int i = 0; i < (int)banks.size(); ++i)
    {
        auto& b = banks[i];
        b.bankName = props.getValue("bankName_" + juce::String(i),
            b.bankName);

        // пресеты
        for (int j = 0; j < 6; ++j)
        {
            b.presetNames.set(j,
                props.getValue("bank_" + juce::String(i)
                    + "_preset_" + juce::String(j),
                    b.presetNames[j]));

            // ccPresetStates
            auto stateStr = props.getValue("bank_" + juce::String(i)
                + "_ccStates_" + juce::String(j),
                "");
            if (stateStr.isNotEmpty())
            {
                juce::StringArray toks(stateStr, ",", "");
                int limit = juce::jmin((int)toks.size(),
                    (int)b.ccPresetStates[j].size());
                for (int k = 0; k < limit; ++k)
                    b.ccPresetStates[j][k] = (toks[k].getIntValue() != 0);
            }

            b.presetVolumes[j] = (float)props.getDoubleValue(
                "bank_" + juce::String(i)
                + "_volume_" + juce::String(j),
                b.presetVolumes[j]);
        }

        // полный CC-mapping
        auto idxTok = juce::StringArray(
            props.getValue("bank_" + juce::String(i) + "_ccParamIndices"),
            ",", "");
        auto enTok = juce::StringArray(
            props.getValue("bank_" + juce::String(i) + "_ccEnabled"),
            ",", "");
        auto valTok = juce::StringArray(
            props.getValue("bank_" + juce::String(i) + "_ccValues"),
            ",", "");

        int count = juce::jmin((int)idxTok.size(),
            juce::jmin((int)enTok.size(),
                juce::jmin((int)valTok.size(),
                    (int)b.ccMappings.size())));

        for (int k = 0; k < count; ++k)
        {
            auto& m = b.ccMappings[k];
            m.paramIndex = idxTok[k].getIntValue();
            m.enabled = (enTok[k].getIntValue() != 0);
            m.ccValue = (uint8_t)juce::jlimit(0, 127,
                valTok[k].getIntValue());
        }

        b.pluginPreset = props.getIntValue(
            "bank_" + juce::String(i) + "_pluginPreset",
            b.pluginPreset);
    }

    // Обновляем UI
    for (int i = 0; i < bankRows.size(); ++i)
    {
        const auto& b = banks[i];
        bankRows[i]->updateFields(b.bankName,
            b.presetNames,
            juce::String(b.pluginPreset));
        bankRows[i]->updateMappingEditors(b.ccMappings);
    }

    if (onBankManagerChanged) onBankManagerChanged();
    updateRowHighlighting();
}

//==============================================================================
// Сбрасываем все банки к дефолтам
//==============================================================================
void BankManager::resetAllDefaults()
{
    static int counter = 1;

    for (auto& b : banks)
    {
        b.bankName = "BANK " + juce::String(counter++);
        b.presetNames.clear();
        for (int j = 0; j < 6; ++j)
            b.presetNames.add("PRESET " + juce::String(j + 1));

        b.ccPresetStates.assign(6, std::vector<bool>(10, false));
        b.presetVolumes.assign(6, 1.0f);

        for (auto& m : b.ccMappings)
            m = CCMapping{};  // default

        b.pluginPreset = 0;
    }

    for (int i = 0; i < bankRows.size(); ++i)
    {
        const auto& b = banks[i];
        bankRows[i]->updateFields(b.bankName,
            b.presetNames,
            juce::String(b.pluginPreset));
        bankRows[i]->updateMappingEditors(b.ccMappings);
    }

    if (onBankManagerChanged) onBankManagerChanged();
    saveSettingsToFile(juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory)
        .getChildFile("BankManagerSettings.ini"));
    updateRowHighlighting();
    restartAutoSaveTimer();
}
void BankManager::loadSettings()
{
    auto f = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory)
        .getChildFile("BankManagerSettings.ini");
    loadSettingsFromFile(f);
}

void BankManager::saveSettings()
{
    auto f = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory)
        .getChildFile("BankManagerSettings.ini");
    saveSettingsToFile(f);
}