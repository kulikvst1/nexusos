#pragma once

// подтянет все модули JUCE, включая String, StringArray, Array<bool> и т.д.
#include <JuceHeader.h>
#include "vst_host.h"   
#include <vector>
#include <array>
#include <functional>
#include "FileManager.h"
#include"SetCCDialog.h"
#include "bank manager.h" 


//==============================================================================
//==============================================================================
// Компонент BankRow — отображает один банк в виде двух строк:
// • Верхняя строка содержит: поле для имени банка, 6 редакторов для имен пресетов,
//   а также редактор для номера пресета плагина.
// • Нижняя строка содержит 10 редакторов для ввода номеров контроллеров (CC mapping).
class BankRow : public juce::Component,
    public juce::TextEditor::Listener
{
public:
    BankRow(int bankIndex, const juce::String& defaultBankName, const juce::StringArray& defaultPresetNames)
        : index(bankIndex)
    {
        // Поле для имени банка
        bankNameEditor.setText(defaultBankName);
        bankNameEditor.addListener(this);
        bankNameEditor.setJustification(juce::Justification::centredLeft);
        addAndMakeVisible(bankNameEditor);

        // Редакторы для имен пресетов (6 шт.)
        for (int i = 0; i < defaultPresetNames.size(); ++i)
        {
            auto* presetEditor = new juce::TextEditor();
            presetEditor->setText(defaultPresetNames[i]);
            presetEditor->addListener(this);
            presetEditor->setJustification(juce::Justification::centred);
            presetEditors.add(presetEditor);
            addAndMakeVisible(presetEditor);
        }

        // Редактор для номера плагин-пресета
        pluginPresetEditor.setText("0");
        pluginPresetEditor.addListener(this);
        pluginPresetEditor.setJustification(juce::Justification::centred);
        pluginPresetEditor.setInputRestrictions(3, "0123456789");
        addAndMakeVisible(pluginPresetEditor);

        // Редакторы для CC mapping (10 шт.)
        for (int i = 0; i < 10; ++i)
        {
            auto* ccEditor = new juce::TextEditor();
            ccEditor->setText(juce::String(i + 1)); // по умолчанию от 1 до 10
            ccEditor->setInputRestrictions(3, "0123456789");
            ccEditor->addListener(this);
            ccMappingEditors.add(ccEditor);
            addAndMakeVisible(ccEditor);
        }
    }

    ~BankRow() override
    {
        bankNameEditor.removeListener(this);
        for (auto* ed : presetEditors)
            ed->removeListener(this);
        for (auto* ed : ccMappingEditors)
            ed->removeListener(this);
        pluginPresetEditor.removeListener(this);
    }

    /** Выделяет или снимает выделение с данной строки. */
    void setHighlighted(bool shouldHighlight)
    {
        isActiveRow = shouldHighlight;
        repaint();
    }

    /** Включает/отключает редактирование поля номера плагин-пресета.
        Если disabled, в поле устанавливается текст "n/a". */
    void setPluginPresetEnabled(bool enabled)
    {
        pluginPresetEditor.setEnabled(enabled);
        pluginPresetEditor.setWantsKeyboardFocus(enabled);
        pluginPresetEditor.setInterceptsMouseClicks(enabled, false);
        if (!enabled)
            pluginPresetEditor.setText("n/a", juce::dontSendNotification);
    }

    void paint(juce::Graphics& g) override
    {
        auto bounds = getLocalBounds().toFloat();
        // Если банк активен, фон красный; иначе – белый.
        if (isActiveRow)
            g.setColour(juce::Colours::red.withAlpha(0.9f));
        else
            g.setColour(juce::Colours::white.withAlpha(0.95f));
        g.fillRoundedRectangle(bounds, 8.0f);
        g.setColour(juce::Colours::grey);
        g.drawRoundedRectangle(bounds, 8.0f, 1.0f);
    }

    void resized() override
    {
        auto bounds = getLocalBounds().reduced(2);
        int totalHeight = bounds.getHeight();
        int topRowHeight = static_cast<int>(totalHeight * 0.6f);
        int bottomRowHeight = totalHeight - topRowHeight;

        // Верхняя строка: сначала поле имени банка
        auto topArea = bounds.removeFromTop(topRowHeight);
        int bankNameWidth = 150;
        bankNameEditor.setBounds(topArea.removeFromLeft(bankNameWidth));

        // Количество колонок: 6 редакторов для пресетов + 1 редактор для номера плагин-пресета
        int numColumns = presetEditors.size() + 1;
        int remainingWidth = topArea.getWidth();
        int eachColWidth = (numColumns > 0) ? remainingWidth / numColumns : 0;

        // Располагаем редакторы для имен пресетов
        for (auto* editor : presetEditors)
            editor->setBounds(topArea.removeFromLeft(eachColWidth));

        // Оставшуюся область выделяем для редактора номера плагин-пресета
        pluginPresetEditor.setBounds(topArea);

        // Нижняя строка: редакторы для CC mapping
        int numCC = ccMappingEditors.size();
        int eachCCWidth = (numCC > 0) ? bounds.getWidth() / numCC : 0;
        for (int i = 0; i < numCC; ++i)
            ccMappingEditors[i]->setBounds(i * eachCCWidth, bounds.getY(), eachCCWidth, bottomRowHeight);
    }

    // Геттеры данных
    juce::String getBankName() const { return bankNameEditor.getText(); }
    juce::String getPresetName(int i) const { jassert(i >= 0 && i < presetEditors.size()); return presetEditors[i]->getText(); }
    int getPluginPresetNumber() const { return pluginPresetEditor.getText().getIntValue(); }
    std::vector<int> getCurrentMapping() const
    {
        std::vector<int> mapping;
        for (int i = 0; i < ccMappingEditors.size(); ++i)
        {
            int val = ccMappingEditors[i]->getText().getIntValue();
            if (val > 127)
                val = 127;
            mapping.push_back(val);
        }
        return mapping;
    }

    /** Новые методы для получения дополнительных данных из UI.
        Пока возвращают значения по умолчанию, замените на свою логику при необходимости.  */
    int getPresetVolume(int presetIndex) const
    {
        // Если у вас позже будет slider или текстовый редактор для громкости, вставьте логику сюда.
        return 64; // Значение по умолчанию
    }

    std::vector<bool> getCCStates(int presetIndex) const
    {
        // Если у вас позже будут переключатели для CC, соберите их состояния.
        // Пока возвращаем вектор из 10 значений false.
        return std::vector<bool>(10, false);
    }

    /** Обновляет поля: имя банка, имена пресетов и значение плагин-пресета. */
    void updateFields(const juce::String& newBankName, const juce::StringArray& newPresetNames, const juce::String& pluginPresetStr)
    {
        bankNameEditor.setText(newBankName, juce::dontSendNotification);
        for (int i = 0; i < presetEditors.size(); ++i)
        {
            if (i < newPresetNames.size())
                presetEditors[i]->setText(newPresetNames[i], juce::dontSendNotification);
        }
        pluginPresetEditor.setText(pluginPresetStr, juce::dontSendNotification);
    }

    /** Обновляет значения редакторов для CC mapping по вектору mapping. */
    void BankRow::updateMappingEditors(const CCMapArray& mapping)
    {
        for (int i = 0; i < ccMappingEditors.size(); ++i)
        {
            const CCMapping& m = mapping[i];
            // текст с ccValue 0…127
            ccMappingEditors[i]->setText(juce::String(m.ccValue),
                juce::dontSendNotification);
            // опционально: если m.enabled==false — дизейблим редактор
            ccMappingEditors[i]->setEnabled(m.enabled);
        }
    }

    // TextEditor Listener
    void textEditorTextChanged(juce::TextEditor& editor) override
    {
        if (&editor == &bankNameEditor)
        {
            if (onRowChanged)
                onRowChanged(index);
        }
        else
        {
            for (int i = 0; i < presetEditors.size(); ++i)
            {
                if (&editor == presetEditors[i])
                {
                    if (onRowChanged)
                        onRowChanged(index);
                    return;
                }
            }
            if (&editor == &pluginPresetEditor)
            {
                if (onRowChanged)
                    onRowChanged(index);
                return;
            }
            for (int i = 0; i < ccMappingEditors.size(); ++i)
            {
                if (&editor == ccMappingEditors[i])
                {
                    int newMapping = editor.getText().getIntValue();
                    if (newMapping > 127)
                        newMapping = 127;
                    if (onMappingChanged)
                        onMappingChanged(index, i, newMapping);
                    return;
                }
            }
        }
    }

    void textEditorReturnKeyPressed(juce::TextEditor& /*editor*/) override {}
    void textEditorEscapeKeyPressed(juce::TextEditor& /*editor*/) override {}
    void textEditorFocusLost(juce::TextEditor& /*editor*/) override {}

    std::function<void(int bankIndex)> onRowChanged;
    std::function<void(int bankIndex, int ccFieldIndex, int newMapping)> onMappingChanged;

private:
    int index{ 0 };
    juce::TextEditor bankNameEditor;
    juce::OwnedArray<juce::TextEditor> presetEditors;
    juce::OwnedArray<juce::TextEditor> ccMappingEditors;
    juce::TextEditor pluginPresetEditor;
    bool isActiveRow{ false };
};
