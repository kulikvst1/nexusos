#pragma once

// подтянет все модули JUCE, включая String, StringArray, Array<bool> и т.д.
#include <JuceHeader.h>
#include "vst_host.h"   
#include <vector>
#include <array>
#include <functional>
#include "FileManager.h"
#include"SetCCDialog.h"

//==============================================================================
//==============================================================================
// Компонент BankRow — отображает один банк в виде двух строк:
// • Верхняя строка содержит: поле для имени банка, 6 редакторов для имен пресетов,
//   а также редактор для номера пресета плагина.
// • Нижняя строка содержит 10 редакторов для ввода номеров контроллеров (CC mapping).
class BankRow : public juce::Component,
    public juce::TextEditor::Listener
{
public:
    BankRow(int bankIndex, const juce::String& defaultBankName, const juce::StringArray& defaultPresetNames)
        : index(bankIndex)
    {
        // Поле для имени банка
        bankNameEditor.setText(defaultBankName);
        bankNameEditor.addListener(this);
        bankNameEditor.setJustification(juce::Justification::centredLeft);
        addAndMakeVisible(bankNameEditor);

        // Редакторы для имен пресетов (6 шт.)
        for (int i = 0; i < defaultPresetNames.size(); ++i)
        {
            auto* presetEditor = new juce::TextEditor();
            presetEditor->setText(defaultPresetNames[i]);
            presetEditor->addListener(this);
            presetEditor->setJustification(juce::Justification::centred);
            presetEditors.add(presetEditor);
            addAndMakeVisible(presetEditor);
        }

        // Редактор для номера плагин-пресета
        pluginPresetEditor.setText("0");
        pluginPresetEditor.addListener(this);
        pluginPresetEditor.setJustification(juce::Justification::centred);
        pluginPresetEditor.setInputRestrictions(3, "0123456789");
        addAndMakeVisible(pluginPresetEditor);

        // Редакторы для CC mapping (10 шт.)
        for (int i = 0; i < 10; ++i)
        {
            auto* ccEditor = new juce::TextEditor();
            ccEditor->setText(juce::String(i + 1)); // по умолчанию от 1 до 10
            ccEditor->setInputRestrictions(3, "0123456789");
            ccEditor->addListener(this);
            ccMappingEditors.add(ccEditor);
            addAndMakeVisible(ccEditor);
        }
    }

    ~BankRow() override
    {
        bankNameEditor.removeListener(this);
        for (auto* ed : presetEditors)
            ed->removeListener(this);
        for (auto* ed : ccMappingEditors)
            ed->removeListener(this);
        pluginPresetEditor.removeListener(this);
    }

    /** Выделяет или снимает выделение с данной строки. */
    void setHighlighted(bool shouldHighlight)
    {
        isActiveRow = shouldHighlight;
        repaint();
    }

    /** Включает/отключает редактирование поля номера плагин-пресета.
        Если disabled, в поле устанавливается текст "n/a". */
    void setPluginPresetEnabled(bool enabled)
    {
        pluginPresetEditor.setEnabled(enabled);
        pluginPresetEditor.setWantsKeyboardFocus(enabled);
        pluginPresetEditor.setInterceptsMouseClicks(enabled, false);
        if (!enabled)
            pluginPresetEditor.setText("n/a", juce::dontSendNotification);
    }

    void paint(juce::Graphics& g) override
    {
        auto bounds = getLocalBounds().toFloat();
        // Если банк активен, фон красный; иначе – белый.
        if (isActiveRow)
            g.setColour(juce::Colours::red.withAlpha(0.9f));
        else
            g.setColour(juce::Colours::white.withAlpha(0.95f));
        g.fillRoundedRectangle(bounds, 8.0f);
        g.setColour(juce::Colours::grey);
        g.drawRoundedRectangle(bounds, 8.0f, 1.0f);
    }

    void resized() override
    {
        auto bounds = getLocalBounds().reduced(2);
        int totalHeight = bounds.getHeight();
        int topRowHeight = static_cast<int>(totalHeight * 0.6f);
        int bottomRowHeight = totalHeight - topRowHeight;

        // Верхняя строка: сначала поле имени банка
        auto topArea = bounds.removeFromTop(topRowHeight);
        int bankNameWidth = 150;
        bankNameEditor.setBounds(topArea.removeFromLeft(bankNameWidth));

        // Количество колонок: 6 редакторов для пресетов + 1 редактор для номера плагин-пресета
        int numColumns = presetEditors.size() + 1;
        int remainingWidth = topArea.getWidth();
        int eachColWidth = (numColumns > 0) ? remainingWidth / numColumns : 0;

        // Располагаем редакторы для имен пресетов
        for (auto* editor : presetEditors)
            editor->setBounds(topArea.removeFromLeft(eachColWidth));

        // Оставшуюся область выделяем для редактора номера плагин-пресета
        pluginPresetEditor.setBounds(topArea);

        // Нижняя строка: редакторы для CC mapping
        int numCC = ccMappingEditors.size();
        int eachCCWidth = (numCC > 0) ? bounds.getWidth() / numCC : 0;
        for (int i = 0; i < numCC; ++i)
            ccMappingEditors[i]->setBounds(i * eachCCWidth, bounds.getY(), eachCCWidth, bottomRowHeight);
    }

    // Геттеры данных
    juce::String getBankName() const { return bankNameEditor.getText(); }
    juce::String getPresetName(int i) const { jassert(i >= 0 && i < presetEditors.size()); return presetEditors[i]->getText(); }
    int getPluginPresetNumber() const { return pluginPresetEditor.getText().getIntValue(); }
    std::vector<int> getCurrentMapping() const
    {
        std::vector<int> mapping;
        for (int i = 0; i < ccMappingEditors.size(); ++i)
        {
            int val = ccMappingEditors[i]->getText().getIntValue();
            if (val > 127)
                val = 127;
            mapping.push_back(val);
        }
        return mapping;
    }

    /** Новые методы для получения дополнительных данных из UI.
        Пока возвращают значения по умолчанию, замените на свою логику при необходимости.  */
    int getPresetVolume(int presetIndex) const
    {
        // Если у вас позже будет slider или текстовый редактор для громкости, вставьте логику сюда.
        return 64; // Значение по умолчанию
    }

    std::vector<bool> getCCStates(int presetIndex) const
    {
        // Если у вас позже будут переключатели для CC, соберите их состояния.
        // Пока возвращаем вектор из 10 значений false.
        return std::vector<bool>(10, false);
    }

    /** Обновляет поля: имя банка, имена пресетов и значение плагин-пресета. */
    void updateFields(const juce::String& newBankName, const juce::StringArray& newPresetNames, const juce::String& pluginPresetStr)
    {
        bankNameEditor.setText(newBankName, juce::dontSendNotification);
        for (int i = 0; i < presetEditors.size(); ++i)
        {
            if (i < newPresetNames.size())
                presetEditors[i]->setText(newPresetNames[i], juce::dontSendNotification);
        }
        pluginPresetEditor.setText(pluginPresetStr, juce::dontSendNotification);
    }

    /** Обновляет значения редакторов для CC mapping по вектору mapping. */
    void BankRow::updateMappingEditors(const CCMapArray& mapping)
    {
        for (int i = 0; i < ccMappingEditors.size(); ++i)
        {
            const CCMapping& m = mapping[i];
            // текст с ccValue 0…127
            ccMappingEditors[i]->setText(juce::String(m.ccValue),
                juce::dontSendNotification);
            // опционально: если m.enabled==false — дизейблим редактор
            ccMappingEditors[i]->setEnabled(m.enabled);
        }
    }

    // TextEditor Listener
    void textEditorTextChanged(juce::TextEditor& editor) override
    {
        if (&editor == &bankNameEditor)
        {
            if (onRowChanged)
                onRowChanged(index);
        }
        else
        {
            for (int i = 0; i < presetEditors.size(); ++i)
            {
                if (&editor == presetEditors[i])
                {
                    if (onRowChanged)
                        onRowChanged(index);
                    return;
                }
            }
            if (&editor == &pluginPresetEditor)
            {
                if (onRowChanged)
                    onRowChanged(index);
                return;
            }
            for (int i = 0; i < ccMappingEditors.size(); ++i)
            {
                if (&editor == ccMappingEditors[i])
                {
                    int newMapping = editor.getText().getIntValue();
                    if (newMapping > 127)
                        newMapping = 127;
                    if (onMappingChanged)
                        onMappingChanged(index, i, newMapping);
                    return;
                }
            }
        }
    }

    void textEditorReturnKeyPressed(juce::TextEditor& /*editor*/) override {}
    void textEditorEscapeKeyPressed(juce::TextEditor& /*editor*/) override {}
    void textEditorFocusLost(juce::TextEditor& /*editor*/) override {}

    std::function<void(int bankIndex)> onRowChanged;
    std::function<void(int bankIndex, int ccFieldIndex, int newMapping)> onMappingChanged;

private:
    int index{ 0 };
    juce::TextEditor bankNameEditor;
    juce::OwnedArray<juce::TextEditor> presetEditors;
    juce::OwnedArray<juce::TextEditor> ccMappingEditors;
    juce::TextEditor pluginPresetEditor;
    bool isActiveRow{ false };
};
// Класс BankManager управляет списком из 15 банков.
 // Один слот CC-кнопки: какой параметр плагина, включён ли он, какое CC-значение шлём
class BankManager
    : public juce::Component,
    public juce::Button::Listener,
    private juce::Timer
{
public:
    // Эти функции будут сохранять/загружать настройки в/из указанного файла.
    void  saveSettingsToFile(const juce::File& configFile);
    void  loadSettingsFromFile(const juce::File& configFile);
    std::vector<int> presetVolume;  // Значения громкости для 6 пресетов
    std::vector<int> ccMapping;     // Для 10 контроллеров
    struct Bank
    {
        // Конструктор, где всё инициализируется через initializer list
        Bank()
            : bankName("Untitled"),
            // задаём ровно 6 имён сразу
            presetNames({ "PRESET 1",
                              "PRESET 2",
                              "PRESET 3",
                              "PRESET 4",
                              "PRESET 5",
                              "PRESET 6" }),
            // 6 векторов по 10 false
            ccPresetStates(6, std::vector<bool>(10, false)),
            // presetVolumes 6 штук со значением 1.0f (0–1.0)
            presetVolumes(6, 1.0f),
            // pluginPreset по-умолчанию 0
            pluginPreset(0)
        {
            // ccMappings – это std::array из 10 элементов,
            // все они уже сконструированы через CCMapping()
            // с параметрами (-1, false, 64).
            // Если хочешь дефолтом 127, раскомментируй:

            // for (auto& m : ccMappings)
            //     m.ccValue = 127;
        }

        juce::String                       bankName;        // имя банка
        juce::StringArray                  presetNames;     // ровно 6 имён
        std::vector<std::vector<bool>>     ccPresetStates;  // [6][10] флагов on/off
        CCMapArray                         ccMappings;      // [10] слотов для CC
        std::vector<float>                 presetVolumes;   // громкости 6 пресетов (0.0–1.0)
        int                                pluginPreset;    // индекс текущего пресета
    };

    // получение копии данных (для Audio/MIDI потока)
    const std::vector<Bank>& getBanks() const { return banks; }
    std::vector<Bank>& getBanks() { return banks; }

    BankManager::BankManager()
    {
        // 1) Model: создаём 15 банков, по 6 пресетов, сбрасываем мэппинги в конструкторе Bank
        banks.resize(15);
        for (int i = 0; i < (int)banks.size(); ++i)
        {
            banks[i].bankName = "BANK " + juce::String(i + 1);
            banks[i].presetNames.clear();
            for (int j = 0; j < 6; ++j)
                banks[i].presetNames.add("PRESET " + juce::String(j + 1));
        }
        currentBankIndex = 0;

        // 2) UI: создаём контейнер для строк и делаем его видимым
        rowContainer = std::make_unique<juce::Component>();
        addAndMakeVisible(rowContainer.get());

        // 3) Создаём по одной BankRow на каждый банк
        const int rowH = 30;    // высота одной строки
        for (int i = 0; i < (int)banks.size(); ++i)
        {
            auto row = std::make_unique<BankRow>(i,
                banks[i].bankName,
                banks[i].presetNames);

            // 3.1) Лямбда сохраняет всё из UI обратно в banks[i]
            row->onRowChanged = [this](int bankIndex)
                {
                    auto& b = banks[bankIndex];
                    b.bankName = bankRows[bankIndex]->getBankName();
                    for (int j = 0; j < 6; ++j)
                    {
                        b.presetNames.set(j, bankRows[bankIndex]->getPresetName(j));
                        b.presetVolumes[j] = bankRows[bankIndex]->getPresetVolume(j);
                        b.ccPresetStates[j] = bankRows[bankIndex]->getCCStates(j);
                    }
                    b.pluginPreset = bankRows[bankIndex]->getPluginPresetNumber();

                    if (onBankManagerChanged) onBankManagerChanged();
                    restartAutoSaveTimer();
                };

            // 3.2) Лямбда меняет только один CC-слот
            row->onMappingChanged = [this](int bankIndex, int ccIndex, int newValue)
                {
                    auto& slot = banks[bankIndex].ccMappings[ccIndex];
                    slot.ccValue = static_cast<uint8_t> (juce::jlimit(0, 127, newValue));
                    slot.enabled = true;

                    if (onBankManagerChanged) onBankManagerChanged();
                    restartAutoSaveTimer();
                };

            // 3.3) Задаём строке явный размер и позицию
            row->setBounds(0, i * rowH, getWidth(), rowH);

            // 3.4) Добавляем в контейнер
            rowContainer->addAndMakeVisible(row.get());
            bankRows.add(std::move(row));
        }
        // --------------- добавляем Set CC-кнопки ---------------
        for (int slot = 0; slot < 10; ++slot)
        {
            auto* btn = new juce::TextButton("Set CC" + juce::String(slot + 1));
            btn->setComponentID(juce::String(slot));      // чтобы потом знать, какая кнопка
            btn->addListener(this);
            addAndMakeVisible(btn);
            setCCButtons.add(btn);
        }
        addAndMakeVisible(viewport);
        viewport.setViewedComponent(rowContainer.get(), false);

        // Добавляем кнопку сброса дефолтных настроек с обработчиком через всплывающее меню
        resetDefaultsButton.setButtonText("Reset Defaults");
        resetDefaultsButton.onClick = [this]()
            {
                juce::PopupMenu popup;
                popup.addItem(1, "Reset Defaults");
                popup.addItem(2, "Save Configuration");
                popup.addItem(3, "Load Configuration");

                popup.showMenuAsync(juce::PopupMenu::Options(), [this](int result)
                    {
                        if (result == 1)
                        {
                            juce::AlertWindow::showOkCancelBox(
                                juce::MessageBoxIconType::WarningIcon,
                                "Reset Defaults",
                                "Are you sure you want to reset all banks to default?",
                                "OK",
                                "Cancel",
                                this,
                                juce::ModalCallbackFunction::create([this](int result)
                                    {
                                        if (result == 1)
                                            resetAllDefaults();
                                    })
                            );
                        }
                        else if (result == 2)
                        {
                            FileManager::chooseSaveFileAsync("Save bank configuration...", "*.ini",
                                [this](const juce::File& selectedFile)
                                {
                                    if (selectedFile != juce::File())
                                        saveSettingsToFile(selectedFile);
                                });
                        }
                        else if (result == 3)
                        {
                            FileManager::chooseLoadFileAsync("Load bank configuration...", "*.ini",
                                [this](const juce::File& selectedFile)
                                {
                                    if (selectedFile.existsAsFile())
                                        loadSettingsFromFile(selectedFile);
                                });
                        }
                    });
            };
        addAndMakeVisible(resetDefaultsButton);

        // Автозагрузка настроек при запуске, обновление подсветки и запуск таймера для автосохранения
        loadSettings();
        updateRowHighlighting();
        startTimer(2000);
    }


    ~BankManager() override { stopTimer(); }

    void restartAutoSaveTimer()
    {
        stopTimer();
        startTimer(2000);
    }

    void timerCallback() override
    {
        saveSettings();
        stopTimer();
    }
    void BankManager::paint(juce::Graphics& g)
    {
        g.fillAll(juce::Colours::transparentBlack);
    }
    void BankManager::buttonClicked(juce::Button* b)
    {
        // 1) Обработка Reset
        if (b == &resetDefaultsButton)
        {
            resetAllDefaults();
            return;
        }

        // 2) Обработка Set CC1…Set CC10
        for (int slot = 0; slot < setCCButtons.size(); ++slot)
        {
            if (setCCButtons[slot] == b)
            {
                // текущее состояние слота
                CCMapping initMap = banks[currentBankIndex].ccMappings[slot];

                // создаём диалог
                auto* dlg = new SetCCDialog(vstHost,
                    initMap,
                    "Set CC " + juce::String(slot + 1),
                    [this, slot](CCMapping newMap, bool ok)
                    {
                        if (!ok)
                            return;

                        banks[currentBankIndex].ccMappings[slot] = newMap;
                        if (onBankManagerChanged)
                            onBankManagerChanged();
                        restartAutoSaveTimer();
                    });

                // центрируем и запускаем как модальное окно
                dlg->centreWithSize(400, 200);
                dlg->enterModalState(true,   // забрать фокус клавиатуры
                    nullptr,// без колбэка на завершение
                    true);  // самосборка при закрытии

                return;
            }
        }
    }

    void BankManager::resized()
    {
        // общий прямоугольник всего компонента
        auto area = getLocalBounds();

        // 1) Верхняя полоса под Set CC-кнопки
        constexpr int topBarHeight = 30;
        auto topBar = area.removeFromTop(topBarHeight);

        int numButtons = (int)setCCButtons.size();
        if (numButtons > 0)
        {
            int btnW = topBar.getWidth() / numButtons;
            for (int i = 0; i < numButtons; ++i)
            {
                setCCButtons[i]->setBounds(
                    topBar.removeFromLeft(btnW).reduced(2));
            }
        }

        // 2) Нижняя полоса под кнопку «Reset to Defaults»
        constexpr int resetBtnH = 40;
        auto bottomBar = area.removeFromBottom(resetBtnH);
        resetDefaultsButton.setBounds(bottomBar.reduced(10));

        // 3) Всё, что осталось, — это viewport
        viewport.setBounds(area);

        // 4) Устанавливаем размер контейнера ровно под одну строку
        constexpr int rowHeight = 100;
        constexpr int gap = 8;
        rowContainer->setSize(viewport.getWidth(),
            rowHeight + gap);

        // 5) Внутри rowContainer показываем только активный BankRow
        for (int i = 0; i < bankRows.size(); ++i)
        {
            auto* row = bankRows[i];
            if (i == currentBankIndex)
            {
                row->setVisible(true);
                row->setBounds(0, 0,
                    rowContainer->getWidth(),
                    rowHeight);
            }
            else
            {
                row->setVisible(false);
            }
        }
    }




    const Bank& getBank(int index) const { jassert(index >= 0 && index < banks.size()); return banks[index]; }
    int getActiveBankIndex() const { return currentBankIndex; }

    void setActiveBankIndex(int newIndex)
    {
        if (newIndex >= 0 && newIndex < (int)banks.size() && newIndex != currentBankIndex)
        {
            currentBankIndex = newIndex;
            if (onBankManagerChanged)
                onBankManagerChanged();
            updateRowHighlighting();
        }
    }

    /** Обновляет подсветку активного банка. */
    void BankManager::updateRowHighlighting()
    {
        // currentBankIndex — ваш индекс “активного” банка
        for (int i = 0; i < bankRows.size(); ++i)
        {
            bool isActive = (i == currentBankIndex);
            bankRows[i]->setVisible(isActive);
            if (isActive)
                bankRows[i]->toFront(false);
        }

        // после смены видимости — обновляем лэйаут
        resized();
    }


    /** Обновляет состояние поля ввода номера плагина-пресета во всех банках.
        Если supported == false, поле блокируется и вместо числа отображается "n/a". */
    void setPluginPresetSupported(bool supported)
    {
        for (auto* row : bankRows)
            row->setPluginPresetEnabled(supported);
    }

    // коллбек, когда данные изменились
    std::function<void()> onBankManagerChanged;



    // Функция по умолчанию для сохранения настроек (вызывается таймером)
    void saveSettings()
    {
        juce::File configFile = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory)
            .getChildFile("BankManagerSettings.ini");
        saveSettingsToFile(configFile);
    }

    // Функция по умолчанию для загрузки настроек (вызывается при запуске)
    void loadSettings()
    {
        juce::File configFile = juce::File::getSpecialLocation(juce::File::userApplicationDataDirectory)
            .getChildFile("BankManagerSettings.ini");
        loadSettingsFromFile(configFile);
    }

    //------------------------------------------------------------------------------
// Сбрасывает все банки к дефолтным настройкам с предварительным подтверждением.
//------------------------------------------------------------------------------
    void BankManager::resetAllDefaults()
    {
        // 1) Сбрасываем модель
        for (auto& b : banks)
        {
            // 1.1) Имя банка и пресеты
            static int counter = 1;
            b.bankName = "BANK " + juce::String(counter++);
            b.presetNames.clear();
            for (int j = 0; j < 6; ++j)
                b.presetNames.add("PRESET " + juce::String(j + 1));

            // 1.2) Состояние CC для каждого пресета (6×10)
            b.ccPresetStates.assign(6, std::vector<bool>(10, false));

            // 1.3) Громкости пресетов (6 значений, 0–127 или 0.0–1.0)
            b.presetVolumes.assign(6, 64.0f);

            // 1.4) CC-mappings (10 слотов) — дефолты из конструктора CCMapping
            for (auto& m : b.ccMappings)
                m = CCMapping{};  // paramIndex=-1, enabled=false, ccValue=64

            // 1.5) Номер пресета плагина
            b.pluginPreset = 0;
        }

        // 2) Обновляем UI (BankRow): поля и CC-мэппинг
        for (int i = 0; i < bankRows.size(); ++i)
        {
            const auto& b = banks[i];

            // Обновляем текстовые поля: имя, пресеты, номер пресета
            bankRows[i]->updateFields(b.bankName,
                b.presetNames,
                juce::String(b.pluginPreset));

            // Обновляем CC-редакторы (под новый тип CCMapArray)
            bankRows[i]->updateMappingEditors(b.ccMappings);
        }

        // 3) Нотификация и автосохранение
        if (onBankManagerChanged)
            onBankManagerChanged();

        // вместо saveSettingsToFile(...) — вызываем обёртку,
        // в которой уже задан путь к INI-файлу
        saveSettings();
    }
private:
    // void timerCallback() override;

    std::vector<Bank>          banks;
    int                        currentBankIndex = 0;
    juce::OwnedArray<BankRow>  bankRows;
    std::unique_ptr<juce::Component> rowContainer;
    juce::Viewport             viewport;
    juce::TextButton           resetDefaultsButton;
    juce::OwnedArray<juce::TextButton> setCCButtons;

    //void buttonClicked(juce::Button* b) override;
    //void resized() override;
    VSTHostComponent* vstHost = nullptr;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(BankManager)
};
